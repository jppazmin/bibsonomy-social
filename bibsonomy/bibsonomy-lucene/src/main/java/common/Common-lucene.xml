<!--


     BibSonomy-Lucene - A blue social bookmark and publication sharing system.

     Copyright (C) 2006 - 2011 Knowledge & Data Engineering Group,
                               University of Kassel, Germany
                               http://www.kde.cs.uni-kassel.de/

     This program is free software; you can redistribute it and/or
     modify it under the terms of the GNU Lesser General Public License
     as published by the Free Software Foundation; either version 2
     of the License, or (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU Lesser General Public License for more details.

     You should have received a copy of the GNU Lesser General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

-->

<!DOCTYPE sqlMap PUBLIC "-//iBATIS.com//DTD SQL Map 2.0//EN" "http://www.ibatis.com/dtd/sql-map-2.dtd">

<sqlMap namespace="Common">
	<resultMap id="resource" class="resource" groupBy="intraHash">
		<result property="interHash"   column="interHash"       javaType="string" />
		<result property="intraHash"   column="intraHash"       javaType="string" />     	
		<!-- <result property="count"       column="count"           javaType="int" /> -->
        <result property="title"       column="title"           javaType="string" />
	</resultMap>

	<resultMap id="posts" class="post" groupBy="contentId">
		<result property="contentId"    column="content_id"     javaType="int" />
		<result property="tags"         resultMap="Common.tag" />
		<result property="date"         column="date"           javaType="date" />
		<result property="groups"       resultMap="Common.group" />
		<result property="user"         resultMap="Common.user" />
		<result property="description"  column="description"    javaType="string" />
	</resultMap>

	<!-- mock post to represent resources from posts generated by the TAS table only -->
	<resultMap id="mockPost" class="post" extends="posts">
	    <!-- the custom type handler maps the content_type to an appropriate
	         resource class -->
		<result property="resource" column="content_type" javaType="Resource" 
		typeHandler="org.bibsonomy.database.common.typehandler.ResourceTypeHandlerCallback" />
	</resultMap>

	<resultMap id="group" class="group" groupBy="groupId">
		<result property="groupId" column="group"       javaType="int" />
		<result property="name"    column="group_name"  javaType="string" />
	</resultMap>

	<resultMap id="user" class="user" groupBy="name">
		<result property="name" column="user_name" javaType="string" />
	</resultMap>

	<resultMap id="tag" class="tag" groupBy="name">
		<result property="name" column="tag_name" javaType="string" />
	</resultMap>

	<!-- spam prediction parameter -->	
	<resultMap id="spamPrediction" class="user">
		<result property="name" column="user_name" javaType="string" />
		<result property="prediction" column="prediction" javaType="integer" />
		<result property="updatedAt" column="updated_at" javaType="date" />
	</resultMap>
	

	<!-- Should be used in conjunction with tagWhereQuery. -->
	<sql id="tagFromQuery">
	    tas t1
		<iterate property="tagIndex">
			<isGreaterThan property="tagIndex[].index" compareValue="1">
				JOIN tas t$tagIndex[].index$ USING (content_id)
			</isGreaterThan>
		</iterate>
	</sql>
    <!-- unfortunately, I had to copy this for the group tas table :-( -->
	<sql id="grouptasTagFromQuery">
	    grouptas t1
		<iterate property="tagIndex">
			<isGreaterThan property="tagIndex[].index" compareValue="1">
				JOIN grouptas t$tagIndex[].index$ USING (content_id)
			</isGreaterThan>
		</iterate>
	</sql>
	<!--
	   Should be used in conjunction with tagFromQuery.

	   Depending on the number of tags it creates a query like:
	        t1.tag_name = 'some-tag'
	    AND t2.tag_name = 'a-tag'
	    AND t3.tag_name = 'another-tag'
	    AND t1.content_id = t2.content_id
	    AND t2.content_id = t3.content_id
	-->
	<sql id="tagWhereQuery">
		<iterate property="tagIndex" conjunction="AND">
		  <isEqual property="caseSensitiveTagNames" compareValue="true">
		    t$tagIndex[].index$.tag_name = #tagIndex[].tagName#
		  </isEqual>
		  <isEqual property="caseSensitiveTagNames" compareValue="false">
		    t$tagIndex[].index$.tag_lower = lower(#tagIndex[].tagName#)
		  </isEqual>
		</iterate>
	</sql>

	<!-- Should be used in conjunction with "conceptWhereQuery". -->
	<sql id="conceptFromQuery">
		<iterate property="tagIndex" conjunction=",">
		  tas t$tagIndex[].index$, 
		  <isEqual property="caseSensitiveTagNames" compareValue="true">
		    (SELECT lower
		     FROM tagtagrelations t$tagIndex[].index$
		     WHERE user_name = #requestedUserName#
		           AND upper = #tagIndex[].tagName#
		     UNION
		     SELECT #tagIndex[].tagName# AS lower
		    ) AS r$tagIndex[].index$
		  </isEqual>
		  <isEqual property="caseSensitiveTagNames" compareValue="false">
		    (SELECT lcase(lower) AS lower
		     FROM tagtagrelations t$tagIndex[].index$
		     WHERE user_name = #requestedUserName#
		           AND lcase(upper) = lcase(#tagIndex[].tagName#)
		     UNION
		     SELECT lcase(#tagIndex[].tagName#) AS lower
		    ) AS r$tagIndex[].index$
		  </isEqual>
		</iterate>
	</sql>

	<!--
	   Should be used in conjunction with conceptFromQuery.
	-->
	<sql id="conceptWhereQuery">
		<iterate property="tagIndex" conjunction="AND">
		  <isEqual property="caseSensitiveTagNames" compareValue="true">
		    t$tagIndex[].index$.tag_name = r$tagIndex[].index$.lower
		  </isEqual>
		  <isEqual property="caseSensitiveTagNames" compareValue="false">
		    t$tagIndex[].index$.tag_lower = r$tagIndex[].index$.lower
		  </isEqual>
		</iterate>
		<!-- Self-Join -->
		<iterate property="tagIndex" prepend="AND" conjunction="AND">
		  <isLessThan property="tagIndex[].index" compareProperty="maxTagIndex">
		    t$tagIndex[].index$.content_id = t$tagIndex[].index2$.content_id
		  </isLessThan>
		</iterate>
	</sql>

	<!--
	   This query is used for get*ForGroupByTag
	   It selects all content ids (for the specific content type)
		- from all users of the group, if userName is allowed to see them
		- from users of group, if userName is friend of one of the users
		- from userName, if in the group
	-->
	<sql id="selectContentIDs">
		((SELECT t1.content_id, t1.date                   <!-- currUser's own items + items from users of group which currUser may see -->
		  FROM groups g, <include refid="tagFromQuery"/>
		  WHERE <include refid="tagWhereQuery"/>
		        AND g.group = #groupId#
		        AND g.user_name = t1.user_name            <!-- all items of all group members (including currUser) -->
		        AND (
		         t1.user_name = #userName#                <!-- currUser's own items -->
		         OR <include refid="inGroupsUnchecked"/>  <!-- items of other users wich currUser may see -->
		        ) 
		        AND t1.content_type = #contentType#
		 ) UNION (
		  SELECT t1.content_id, t1.date             <!-- items from users of group which have currUser as friend -->
		  FROM groups g, friends f, <include refid="tagFromQuery"/>
		  WHERE <include refid="tagWhereQuery"/>
		        AND g.group = #groupId#
		        AND f.f_user_name = #userName#      <!-- currUser is friend of user -->
		        AND g.user_name = f.user_name       <!-- user is in group -->
		        AND t1.user_name = f.user_name      <!-- user owns this item -->              
		        AND t1.group = $groupType$          <!-- item is only for friends -->
		        AND t1.content_type = #contentType#
		 )
		ORDER BY date DESC
		LIMIT #limit# OFFSET #offset#) AS bb
	</sql>
	
	<!--
	   This query is used for get*ForGroupByTag queries that want to retrieve documents
	   It selects all content ids (for the specific content type)
		- from all users of the group, if userName is allowed to see them
		- from users of group, if userName is friend of one of the users
		- from userName, if in the group
	-->
	<sql id="selectContentIDsWithDocuments">
		((SELECT t1.content_id, t1.date, d.hash, d.name         <!-- currUser's own items + items from users of group which currUser may see -->
		  FROM groups g, document d, <include refid="tagFromQuery"/>
		  WHERE <include refid="tagWhereQuery"/>
		        AND g.group = #groupId#
		        AND g.user_name = t1.user_name            <!-- all items of all group members (including currUser) -->
		        AND (
		         t1.user_name = #userName#                <!-- currUser's own items -->
		         OR <include refid="inGroupsUnchecked"/>  <!-- items of other users wich currUser may see -->
		        ) 
		        AND d.content_id = t1.content_id		  <!-- join documents -->
		        AND t1.content_type = #contentType#
		 ) UNION (
		  SELECT t1.content_id, t1.date, d.hash, d.name           <!-- items from users of group which have currUser as friend -->
		  FROM groups g, friends f, document d, <include refid="tagFromQuery"/>
		  WHERE <include refid="tagWhereQuery"/>
		        AND g.group = #groupId#
		        AND f.f_user_name = #userName#      <!-- currUser is friend of user -->
		        AND g.user_name = f.user_name       <!-- user is in group -->
		        AND t1.user_name = f.user_name      <!-- user owns this item -->              
		        AND t1.group = $groupType$          <!-- item is only for friends -->
		        AND d.content_id = t1.content_id	<!-- join documents -->
		        AND t1.content_type = #contentType#
		 )
		ORDER BY date DESC
		LIMIT #limit# OFFSET #offset#) AS bb
	</sql>

	<!-- 
		restrict visibility of retrieved items to
		* an explicitly given group (groupId given) or
		* all groups the user may see (inclusion of inGroups)
	 -->
	<sql id="restrictToGroups">
		<isEqual property="groupId" compareValue="-1">
		  <!-- no user logged in -> only public posts -->
		  <isEmpty property="userName" prepend="AND">
		  	t1.group = 0 
		  </isEmpty>
		  <!-- user logged in -> check his groups -->
		  <isNotEmpty property="userName">
		  	<include refid="inGroups"/>
		  </isNotEmpty>
		</isEqual>
		<isGreaterThan property="groupId" compareValue="-1" prepend="AND">
		  t1.group = #groupId#
		</isGreaterThan>	
	</sql>
	
	<sql id="restrictToGroups2">
		<isEqual property="groupId" compareValue="-1">
		  <!-- no user logged in -> only public posts -->
		  <isEmpty property="userName" prepend="AND">
		  	t1.group = 0 
		  </isEmpty>
		  <!-- user logged in -> check his groups -->
		  <isNotEmpty property="userName">
		  	<include refid="inGroups3"/>
		  </isNotEmpty>
		</isEqual>
		<isGreaterThan property="groupId" compareValue="-1" prepend="AND">
		  t1.group = #groupId#
		</isGreaterThan>	
	</sql>
	
	<!-- restrict visibility of retrieved items to the groups a user may see -->	
	<sql id="inGroups">
	    <!-- no user logged in - only public posts -->
		<isEmpty property="userName" prepend="AND">
		  	t1.group = 0 
		</isEmpty>
		<!-- a user is logged in - check groups -->
		<isNotEmpty property="userName">
		  <isNotEqual property="userName" compareProperty="requestedUserName" prepend="AND">		
			  <include refid="inGroupsUnchecked"/>
		  </isNotEqual>
		</isNotEmpty>
	</sql>
	
	<!-- restrict visibility of retrieved items to the groups a user may see -->	
	<sql id="inGroups3">
	    <!-- no user logged in - only public posts -->
		<isEmpty property="userName" prepend="AND">
		  	t1.group = 0 
		</isEmpty>
		<!-- a user is logged in - check groups -->
		<isNotEmpty property="userName">
		  <isNotEqual property="userName" compareProperty="requestedUserName" prepend="AND">		
			  t1.group = 0 
		  </isNotEqual>
		  <isEqual property="userName" compareProperty="requestedUserName" prepend="AND">		
			  t1.group &lt; 2
		  </isEqual>
		</isNotEmpty>
	</sql>
	
	<!-- restrict visibility directly, i.e. without checking for user's own items -->
	<sql id="inGroupsUnchecked">
		t1.group in (
		<iterate property="groups" conjunction=",">
		    $groups[]$
		</iterate>)	
	</sql>
	
	<!-- 
	  TODO:
	  It would be good, to not "invent" a new SQL snippet for each differently named
	  table. Either, name the table in the corresponding statement appropriately
	  (e.g., "t1"), or introduce a parameter.
	-->
	<!-- restrict visibility directly, i.e. without checking for user's own items -->
	<sql id="inGroupsUnchecked2">
		t2.group in (
		<iterate property="groups" conjunction=",">
		    $groups[]$
		</iterate>)	
	</sql>
		
	<!-- 
		 this only needed for getBibTexDuplicate, as refactoring that query to
	     use t1 as table alias instead of b would have had some unwanted side-effects
	     dbe, 20080220
	-->
	<sql id="inGroups2">
		<isNotEqual property="userName" compareProperty="requestedUserName" prepend="AND">
		  b.group in (
		  <iterate property="groups" conjunction=",">
		    $groups[]$
		  </iterate>)
		</isNotEqual>
	</sql>	

	<!-- retrieve items by resource type -->
	<sql id="getTagsByResourceType">
		<isNotNull property="contentType">
			<isGreaterThan property="contentType" compareValue="0" prepend="AND">
				t1.content_type = #contentType#
			</isGreaterThan>
		</isNotNull>
	</sql>
	
	<!-- necessary to decide the 4 types of system tag year request
	1. 2007
	2. 2005-2007
	3. -2005
	4. 2005-
	 -->
	<sql id="sysTagsYear">
		<dynamic prepend="AND">
			<isNotNull property="year">		
				CAST(b.year AS SIGNED) = #year#
			</isNotNull>
			<isNotNull property="firstYear">
				<isNotNull property="lastYear">
				CAST(b.year AS SIGNED) BETWEEN #firstYear# AND #lastYear#
				</isNotNull>
			</isNotNull>
			<isNotNull property="firstYear">
				<isNull property="lastYear">
				CAST(b.year AS SIGNED) >= #firstYear#
				</isNull>
			</isNotNull>
			<isNotNull property="lastYear">
				<isNull property="firstYear">
				CAST(b.year AS SIGNED) &lt;= #lastYear#
				</isNull>
			</isNotNull>
		</dynamic>
	</sql>
	
	<!-- dynamic AND for systag user -->
	<sql id="sysTagsUser">
		<dynamic prepend="AND">
			<isNotNull property="requestedUserName">		
				s.user_name = #requestedUserName#
			</isNotNull>
		</dynamic>
	</sql>
	
	<!-- dynamic AND for systag entrytype -->
	<sql id="sysTagsEntryType">
		<dynamic prepend="AND">
			<isNotNull property="entryType">		
				b.entrytype = #entryType#
			</isNotNull>
		</dynamic>
	</sql>
	
	<!-- dynamic AND for systag group -->
	<sql id="sysTagsGroup">
		<dynamic prepend="AND">
			<isNotNull property="requestedGroupName">		
				s.user_name IN (SELECT user_name 
								FROM groupids g JOIN groups gs ON (g.group = gs.group)
	        					WHERE g.group_name = #requestedGroupName#)
			</isNotNull>
		</dynamic>
	</sql>
	
	<!-- retrieves names of groupmembers of specified group -->
	<sql id="selectGroupMembers">
		SELECT g.user_name
      	FROM groupids gi JOIN groups g ON (gi.group = g.group)
      	WHERE group_name = #requestedGroupName#
	</sql>
	
</sqlMap>